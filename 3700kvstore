#!/usr/bin/env python

import sys
import socket
import select
import time
import json
import random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

currentTerm = 1                       # the current term
votedFor = ''                         # who I voted for this election
log = []                              # my log of commands for state machine
database = []                         # the state machine
commitIndex = 0                       # index of highest log entry known to be committed
lastApplied = 0                       # index of highest log entry applied to state machine
nextIndex = {}                        # for leader; next index to send to each follower
matchIndex = {}                       # for leader; index of highest log entry known to be replicated there

status = 'follower'                   # current status
leaderID = ''                         # ID of known leader
lastReceivedFromLeader = time.time()  # the time when I last received a message from the leader
lastSentToFollowers = ''              # the time when I last sent a message to my followers
votesGranted = {}                     # candidates use; who voted/didn't vote for me
lastLogIndex = 0                      # index of my last log entry
lastLogTerm = 0                       # term of my last log entry
num_servers = len(replica_ids) + 1    # number of servers (including me)


# send message to sock
def sock_send(message):
  sock.send(json.dumps(message))


# initiate leader election
def initiate_election():
  global currentTerm
  global leaderID
  global status
  global votedFor
  global votesGranted
  global lastReceivedFromLeader

  # increment term, change leader id to unknown, i am now a candidate, vote for myself, send to other servers
  currentTerm += 1
  leaderID = 'FFFF'
  status = 'candidate'
  votedFor = my_id
  votesGranted[my_id] = True
  lastReceivedFromLeader = time.time()
  for rid in replica_ids:
    vote_msg = {'src': my_id, 'dst': rid, 'leader': leaderID, 'type': 'RequestVote',
                'term': currentTerm, 'lastLogIndex': lastLogIndex, 'lastLogTerm': lastLogTerm}
    sock.send(json.dumps(vote_msg))


# get the number of votes granted to me in election
def get_num_votes():
  global votesGranted

  num_votes = 0

  for x in votesGranted:
    if votesGranted[x] is True:
      num_votes += 1

  return num_votes


# set my election timeout to random number between .1 and .2 seconds
election_timeout = random.randrange(100, 200) / float(1000)

# main while loop
while True:
  ready = select.select([sock], [], [], 0)[0]

  # received a message
  if sock in ready:
    msg_raw = sock.recv(32768)

    if len(msg_raw) == 0:
      continue

    msg = json.loads(msg_raw)

    # message is from leader
    if msg['src'] == leaderID:
      lastReceivedFromLeader = time.time()

    # For now, ignore get() and put() from clients
    if msg['type'] in ['get', 'put']:
      pass

    # someone requested a vote
    elif msg['type'] == 'RequestVote':
      # this is from a previous term; decline
      if msg['term'] < currentTerm:
        new_msg = {'src': my_id, 'dst': msg['src'], 'leader': leaderID, 'type': 'ResponseVote',
                   'voteGranted': False, 'term': currentTerm}

      # either this is for a higher term, or for this term and i already voted for this server
      elif msg['term'] > currentTerm or (votedFor == msg['src'] and msg['term'] == currentTerm):
        currentTerm = msg['term']
        votedFor = msg['src']
        leaderID = 'FFFF'
        lastReceivedFromLeader = time.time()
        new_msg = {'src': my_id, 'dst': msg['src'], 'leader': leaderID, 'type': 'ResponseVote',
                   'voteGranted': True, 'term': currentTerm}
      # in this election, i already voted for someone else
      else:
        new_msg = {'src': my_id, 'dst': msg['src'], 'leader': leaderID, 'type': 'ResponseVote',
                   'voteGranted': False, 'term': currentTerm}
      sock_send(new_msg)

    # candidate use; someone responded to my vote request
    elif msg['type'] == 'ResponseVote':
      votesGranted[msg['src']] = msg['voteGranted']
      # i have a quorum of votes - i am leader!
      if get_num_votes() >= (num_servers / 2) + 1:
        election_timeout = None
        status = 'leader'
        leaderID = my_id
        lastSentToFollowers = time.time()
        for rid in replica_ids:
          new_msg = {'src': my_id, 'dst': rid, 'leader': leaderID,
                      'type': 'Heartbeat', 'term': currentTerm}
          sock_send(new_msg)

    # heartbeat received
    elif msg['type'] == 'Heartbeat':
      if msg['term'] >= currentTerm:
        # this is from a new leader, reset election timeout
        if leaderID == 'FFFF':
          election_timeout = random.randrange(100, 200) / float(1000)

        # reset the following values
        lastReceivedFromLeader = time.time()
        votesGranted = {}
        votedFor = ''
        leaderID = msg['leader']
        status = 'follower'

  # it's been too long since i've heard from the leader; initiate election
  if status != 'leader' and time.time() - lastReceivedFromLeader >= election_timeout:
    initiate_election()

  # time to send a heartbeat message to my followers
  elif status == 'leader' and time.time() - lastSentToFollowers >= .1:
    lastSentToFollowers = time.time()
    for rid in replica_ids:
      new_msg = {'src': my_id, 'dst': rid, 'leader': leaderID,
                 'type': 'Heartbeat', 'term': currentTerm}
      sock_send(new_msg)

#import sys
#import socket
#import select
#import json
#import random
#import time

# Your ID number
#my_id = sys.argv[1]

# The ID numbers of all the other replicas
#replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
#sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
#sock.connect(my_id)

#highest_committed_index = 0
#index = 1
#term = 0
#leader = 'FFFF'
#state = 'follower'
#database = {}
#voted = False
#votes = 0
#num_servers = len(replica_ids) + 1
#backlog = {}
#history = {}
#nexts = {}
#num_commits = 0
#num_appendentries = 0
#num_appendentries_back = 0
#num_appendfailures = 0
#num_requestvote = 0
#num_vote = 0
#num_leader = 0
#num_heartbeat = 0
#num_appendfailures_back = 0
#last_heartbeat = ''
#lasttime = 0
#first = False
#has_been_leader = True


# initiate leader election
#def initiate_election():
#	global state
#	global sock
#	global term
#	global voted
#	global votes
#	global leader
#	global num_requestvote

# print my_id, 'is initiating election'
#	term += 1
#	leader = 'FFFF'
#	state = 'candidate'
#	voted = True
#	votes += 1
#	for rid in replica_ids:
#		vote_msg = {'src': my_id, 'dst': rid, 'leader': leader, 'type': 'RequestVote', 'term': term}
#		num_requestvote += 1
#		sock.send(json.dumps(vote_msg))


# commit entries in the backlog until this index
#def commit_till(index):
#	global highest_committed_index

#	while index > highest_committed_index:
#		highest_committed_index += 1
#		do_this = backlog[highest_committed_index]
#		database[do_this['key']] = do_this['value']
#
#
# send message to sock
#def sock_send(msg):
#if msg['type'] != 'vote' and msg['type'] != 'leader':
#	print my_id, '(', time.time(), ') :', msg
#if msg['type'] == 'redirect':
#	print my_id, '(', time.time(), ') :', msg
#	sock.send(json.dumps(msg))


#election_timeout = random.randrange(100, 200) / float(1000)

#while True:
#	ready = select.select([sock], [], [], election_timeout)[0]

#	if sock in ready:
#		msg_raw = sock.recv(32768)
#
#		if len(msg_raw) == 0:
#			continue

#		msg = json.loads(msg_raw)

#		# For now, ignore get() and put() from clients
#		if msg['type'] in ['get', 'put']:
#			if state != 'leader':
#				new_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'redirect', 'MID': msg['MID']}
#				sock_send(new_msg)
#			else:
#				has_been_leader = True
#				#print my_id, '(', time.time(), ') :', msg
#				if msg['type'] == 'put':
#					#add_to_log = {'key': msg['key'], 'value': msg['value'], 'MID': msg['MID'], 'term': term,
#							'src': msg['src'], 'confirms': 1, 'confirmed': False, 'index': index}
#backlog[index] = add_to_log
#					index += 1
#					database[msg['key']] = msg['value']
#					ok_msg = {'src': my_id, 'dst': msg['src'], 'type': 'ok', 'leader': leader, 'MID': msg['MID']}
#					sock_send(ok_msg)
#					for rid in replica_ids:
#						replicas_msg = {'src': my_id, 'dst': rid, 'leader': leader, 'type': 'heartbeat', 'MID': msg['MID'],
#														'term': term, 'highest_committed_index': highest_committed_index}

#replicas_msg = {'key': msg['key'], 'value': msg['value'], 'MID': msg['MID'], 'term': term,
#								'src': my_id, 'dst': rid, 'leader': leader, 'type': 'AppendEntries',
#								'index': index - 1, 'highest_committed_index': highest_committed_index}
#						num_appendentries += 1
#						sock_send(replicas_msg)
#				else:
#if last_heartbeat != '':
#	print time.time() - last_heartbeat
#					for rid in replica_ids:
#						replicas_msg = {'src': my_id, 'dst': rid, 'leader': leader, 'type': 'heartbeat', 'MID': msg['MID'],
#																						'term': term, 'highest_committed_index': highest_committed_index}
#						num_heartbeat += 1
#						last_heartbeat = time.time()
#						sock_send(replicas_msg)
#print database
#					try:
#						new_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'ok', 'MID': msg['MID'],
#																	'value': database[msg['key']]}
#						sock_send(new_msg)
#					except KeyError:
#						print 'DATABASE:', database, '\nMSG:', msg
#						sys.exit(0)

#		elif msg['type'] == 'RequestVote':
#			if msg['term'] > term:
#				term = msg['term']
#				voted = True
#				leader = 'FFFF'
#				new_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'vote', 'granted': True, 'term': term}
#			else:
#				new_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'vote', 'granted': False, 'term': term}
#			num_vote += 1
#			sock_send(new_msg)

#		elif msg['type'] == 'vote':
#			if msg['term'] == term and msg['granted'] and state != 'leader':
#				votes += 1
#				if votes >= (num_servers / 2) + 1:
#					election_timeout = None
#					# print my_id, ': i am now the leader!'
#					leader = my_id
#					votes = 0
#					first = False
#					state = 'leader'
#					lasttime = time.time()
#					for rid in replica_ids:
#						nexts[rid] = index
#					for rid in replica_ids:
#						new_msg = {'src': my_id, 'dst': rid, 'leader': leader, 'type': 'leader', 'term': term}
#						num_leader += 1
#						sock_send(new_msg)


#		elif msg['type'] == 'leader':
#			# print my_id, ':', msg['leader'], 'is now the leader'
#			election_timeout = random.randrange(100, 200) / float(1000)
#			state = 'follower'
#			voted = False
#			votes = 0
#			term = msg['term']
#			leader = msg['leader']
#			if has_been_leader:
#				data_msg = {'src': my_id, 'dst': leader, 'type': 'data', 'leader': leader, 'data': database}

#		elif msg['type'] == 'data' and state == 'leader':
#			#print database
#			database.update(msg['data'])
#			#print database
#
#print my_id, '; num_request_vote', num_requestvote, '; num_append_entries', num_appendentries, \
#	'; num_append_entries_back', num_appendentries_back, ';num_append_failures', num_appendfailures, \
#	'; num_append_failures_back', num_appendfailures_back, '; num_commits', num_commits,\
#	'; num_leader', num_leader, '; num_vote', num_vote, '; num_heartbeat', num_heartbeat

#elif msg['type'] == 'AppendEntries' and state != 'leader':
#	if msg['highest_committed_index'] > highest_committed_index:
#		commit_till(msg['highest_committed_index'])
#	if msg['term'] == term and index == msg['index']:
#		backlog[msg['index']] = {'key': msg['key'], 'value': msg['value'], 'MID': msg['MID'], 'term': term, 'src': msg['src'], 'index': msg['index'], 'confirmed': False}
#		index += 1
#		new_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'AppendEntries', 'MID': msg['MID'], 'term': term, 'index': msg['index']}
#		num_appendentries_back += 1
#		sock_send(new_msg)
#	elif msg['term'] == term:
#		try:
#			b = backlog[msg['index']]
#			index += 1
#			new_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'AppendEntries', 'MID': msg['MID'],
#								 'term': term, 'index': index - 1}
#			num_appendentries_back += 1
#			sock_send(new_msg)
#		except KeyError:
#			index = msg['index']
#			backlog[msg['index']] = {'key': msg['key'], 'value': msg['value'], 'MID': msg['MID'], 'term': term, 'src': msg['src']}
#			new_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'AppendFailure'}
#			num_appendfailures += 1
#			sock_send(new_msg)

#elif msg['type'] == 'AppendEntries' and state == 'leader':
#	if msg['term'] == term:
#		nexts[msg['src']] += 1
#		log_entry = backlog[msg['index']]
#		if not log_entry['confirmed']:
#			log_entry['confirms'] += 1
#			if log_entry['confirms'] >= (num_servers / 2) + 1:
#				log_entry['confirmed'] = True
#				database[log_entry['key']] = log_entry['value']
#				ok_msg = {'src': my_id, 'dst': log_entry['src'], 'type': 'ok', 'leader': leader, 'MID': log_entry['MID']}
#				sock_send(ok_msg)
#				highest_committed_index += 1
#				for rid in replica_ids:
#					commit_msg = {'src': my_id, 'dst': rid, 'leader': leader, 'type': 'commit', 'MID': msg['MID'], 'index': log_entry['index'], 'term': term}
#					num_commits += 1
#					sock_send(commit_msg)

#		elif msg['type'] == 'commit':
#			if msg['term'] == term:
#				try:
#					log_entry = backlog[msg['index']]
#					highest_committed_index = msg['index']
#					database[log_entry['key']] = log_entry['value']
#				except KeyError:
#					pass
#
#		elif msg['type'] == 'AppendFailure':
#			if msg['term'] == term:
#				nexts[msg['src']] -= 1
#				replicas_msg = backlog[index - 1]
#				replicas_msg['src'] = my_id
#				replicas_msg['dst'] = msg['src']
#				replicas_msg['leader'] = leader
#				replicas_msg['type'] = 'AppendEntries'
#				replicas_msg['index'] = nexts[msg['src']]
#				replicas_msg['highest_committed_index'] = highest_committed_index
#				num_appendfailures_back += 1
#				sock_send(replicas_msg)

#	else:
#		initiate_election()

#clock = time.time()
#print clock
#if clock - last > 2:
# Send a no-op message to a random peer every two seconds, just for fun
# You definitely want to remove this from your implementation
# msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
# sock.send(json.dumps(msg))
# print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
#last = clock
